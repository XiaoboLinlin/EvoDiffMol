#!/usr/bin/env python3

import os
from rdkit import Chem

def write_mol2_structure(mol, pos, smile, output_path, update_mask=None):
    """
    Write 3D structure in MOL2 format (most reliable for complex molecules).
    
    Args:
        mol: RDKit molecule object
        pos: 3D positions (N x 3 tensor)
        smile: SMILES string (may be in square bracket notation)
        output_path: Output MOL2 file path
        update_mask: Optional tensor indicating fixed atoms (0=fixed, 1=generated)
    
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Validate molecule atom count consistency
        mol_validated, pos_validated = validate_molecule_atom_count(mol, pos, smile)
        if mol_validated is None:
            print(f"Warning: Atom count mismatch for {output_path}")
            return False
        
        # Use the validated molecule and positions
        mol = mol_validated
        pos = pos_validated
        
        # Remove all radicals before generating canonical SMILES
        for atom in mol.GetAtoms():
            if atom.GetNumRadicalElectrons() != 0:
                atom.SetNumRadicalElectrons(0)
        # Generate canonical SMILES from the molecule object (not from the input SMILES)
        canonical_smiles = smile  # fallback to original
        try:
            # Generate canonical SMILES directly from the molecule object
            canonical_smiles = Chem.MolToSmiles(mol, canonical=True)
        except Exception as e:
            # If that fails, try to convert the input SMILES
            try:
                mol_from_smiles = Chem.MolFromSmiles(smile)
                if mol_from_smiles is not None:
                    canonical_smiles = Chem.MolToSmiles(mol_from_smiles, canonical=True)
            except:
                # If all else fails, use original SMILES
                canonical_smiles = smile
        
        # Analyze fixed vs generated atoms if update_mask is provided
        fixed_atom_count = 0
        generated_atom_count = 0
        if update_mask is not None:
            fixed_indices = (update_mask == 0).nonzero(as_tuple=True)[0].tolist()
            generated_indices = (update_mask == 1).nonzero(as_tuple=True)[0].tolist()
            fixed_atom_count = len(fixed_indices)
            generated_atom_count = len(generated_indices)
        
        with open(output_path, 'w') as f:
            # Write enhanced header with structure information
            f.write("# MOL2 file generated by EvoDiffMol\n")
            f.write(f"# SMILES: {canonical_smiles}\n")
            
            if update_mask is not None:
                f.write(f"# FIXED STRUCTURE GENERATION:\n")
                f.write(f"#   Fixed atoms (scaffold): {fixed_atom_count} atoms (marked with 'FIXED_*')\n")
                f.write(f"#   Generated atoms: {generated_atom_count} atoms (marked with 'GEN_*')\n")
                f.write(f"#   Fixed atom indices: {fixed_indices}\n")
                f.write(f"#   Generated atom indices: {generated_indices}\n")
                f.write("#\n")
                f.write("# VISUALIZATION TIPS:\n")
                f.write("#   - Fixed atoms (scaffold) can be colored/highlighted differently\n")
                f.write("#   - Search for 'FIXED_' in atom names to identify scaffold atoms\n")
                f.write("#   - Search for 'GEN_' in atom names to identify generated atoms\n")
            f.write("\n")
            
            # Write molecule record
            f.write("@<TRIPOS>MOLECULE\n")
            if update_mask is not None:
                f.write("Generated_Molecule_with_Fixed_Scaffold\n")
            else:
                f.write("Generated_Molecule\n")
            f.write(f"{mol.GetNumAtoms()} {mol.GetNumBonds()} 0 0 0\n")
            f.write("SMALL\n")
            f.write("USER_CHARGES\n\n")
            
            # Write atom records with clear fixed/generated labels
            f.write("@<TRIPOS>ATOM\n")
            for i in range(mol.GetNumAtoms()):
                atom = mol.GetAtomWithIdx(i)
                symbol = atom.GetSymbol()
                x, y, z = pos[i]
                
                # Create descriptive atom name based on whether it's fixed or generated
                if update_mask is not None:
                    if update_mask[i] == 0:  # Fixed atom
                        atom_name = f"FIXED_{symbol}{i+1}"
                        subst_name = "SCAFFOLD"
                    else:  # Generated atom
                        atom_name = f"GEN_{symbol}{i+1}"
                        subst_name = "GENERATED"
                else:
                    atom_name = f"{symbol}{i+1}"
                    subst_name = "MOL"
                
                # MOL2 format: atom_id, atom_name, x, y, z, atom_type, subst_id, subst_name, charge
                line = f"{i+1:7d} {atom_name:12s} {x:9.4f} {y:9.4f} {z:9.4f} {symbol:6s} 1 {subst_name:8s} 0.0000\n"
                f.write(line)
            
            # Write bond records
            f.write("@<TRIPOS>BOND\n")
            bond_id = 1
            for bond in mol.GetBonds():
                begin_idx = bond.GetBeginAtomIdx() + 1
                end_idx = bond.GetEndAtomIdx() + 1
                bond_type = bond.GetBondType()
                
                # Convert bond type to MOL2 format
                if bond_type == Chem.BondType.SINGLE:
                    bond_str = "1"
                elif bond_type == Chem.BondType.DOUBLE:
                    bond_str = "2"
                elif bond_type == Chem.BondType.TRIPLE:
                    bond_str = "3"
                elif bond_type == Chem.BondType.AROMATIC:
                    bond_str = "ar"
                else:
                    bond_str = "1"
                
                line = f"{bond_id:6d} {begin_idx:6d} {end_idx:6d} {bond_str:6s}\n"
                f.write(line)
                bond_id += 1
            
            # Write substructure records with clear labeling
            f.write("@<TRIPOS>SUBSTRUCTURE\n")
            if update_mask is not None:
                # Write separate substructures for fixed and generated parts
                f.write("1 SCAFFOLD 1 TEMP 0 **** **** 0 ROOT\n")
                if generated_atom_count > 0:
                    f.write("2 GENERATED 1 TEMP 0 **** **** 0 ROOT\n")
            else:
                f.write("1 MOL 1 TEMP 0 **** **** 0 ROOT\n")
        
        return True
    except Exception as e:
        print(f"Error writing MOL2 file {output_path}: {e}")
        return False

def validate_molecule_atom_count(mol, pos, smile):
    """
    Validate molecule by checking atom count consistency between SMILES and 3D structure.
    
    Args:
        mol: RDKit molecule object
        pos: 3D positions (N x 3 tensor)
        smile: SMILES string
    
    Returns:
        tuple: (mol, pos) or (None, None) if validation fails
    """
    try:
        # Check basic consistency (atom count between SMILES and 3D structure)
        if not validate_molecule_consistency(mol, pos, smile):
            return None, None
        
        # If validation passes, return the original molecule and positions
        return mol, pos
            
    except Exception as e:
        print(f"  ❌ Error in validate_molecule_atom_count: {e}")
        return None, None



def validate_molecule_consistency(mol, pos, smile):
    """
    Validate that SMILES and 3D structure have the same number of atoms.
    
    Args:
        mol: RDKit molecule object
        pos: 3D positions (N x 3 tensor)
        smile: SMILES string
    
    Returns:
        bool: True if atom counts match, False otherwise
    """
    try:
        # Check if the molecule object is valid
        if mol is None:
            print(f"  ❌ Molecule object is None")
            return False
        
        # Check atom count consistency between molecule and positions
        mol_atoms = mol.GetNumAtoms()
        pos_atoms = len(pos)
        
        if mol_atoms != pos_atoms:
            print(f"  ❌ Position count mismatch: molecule={mol_atoms}, positions={pos_atoms}")
            return False
        
        # Check if positions tensor has correct shape
        if len(pos.shape) != 2 or pos.shape[1] != 3:
            print(f"  ❌ Invalid position tensor shape: {pos.shape}, expected (N, 3)")
            return False
        
        # For visualization purposes, allow SMILES vs molecule atom count mismatch
        # This is normal when SMILES shows heavy atoms but molecule includes hydrogens
        mol_from_smiles = Chem.MolFromSmiles(smile)
        if mol_from_smiles is not None:
            smiles_atoms = mol_from_smiles.GetNumAtoms()
            if mol_atoms != smiles_atoms:
                print(f"  ℹ️  Note: SMILES has {smiles_atoms} heavy atoms, molecule has {mol_atoms} total atoms (including H)")
        else:
            print(f"  ⚠️  SMILES parsing failed: {smile} - continuing with 3D structure")
        
        return True
        
    except Exception as e:
        print(f"  ❌ Validation error: {e}")
        return False

def test_mol2_writer():
    """Test the MOL2 writer with a sample molecule."""
    from rdkit.Chem import AllChem
    import numpy as np
    
    # Test with molecule 44 SMILES
    test_smiles = "CN(Cc1cnn(C)c1C1CCCC1)C(O)N1CCCCN2CCCC2C1"
    
    print(f"Testing MOL2 writer with SMILES: {test_smiles}")
    
    # Create molecule and generate 3D coordinates
    mol = Chem.MolFromSmiles(test_smiles)
    if mol is None:
        print("❌ Could not create molecule from SMILES")
        return
    
    # Generate 3D coordinates
    AllChem.EmbedMolecule(mol, randomSeed=42)
    AllChem.MMFFOptimizeMolecule(mol)
    
    # Get positions
    conf = mol.GetConformer()
    pos = []
    for i in range(mol.GetNumAtoms()):
        pos.append(conf.GetAtomPosition(i))
    pos = np.array(pos)
    
    # Test MOL2 writing
    output_path = "test_mol2_molecule_44.mol2"
    success = write_mol2_structure(mol, pos, test_smiles, output_path)
    
    if success:
        print(f"✅ Successfully wrote MOL2 to {output_path}")
        print(f"File size: {os.path.getsize(output_path)} bytes")
    else:
        print("❌ Failed to write MOL2 file")

if __name__ == "__main__":
    test_mol2_writer() 